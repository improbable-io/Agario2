// Generated by SpatialOS codegen. DO NOT EDIT!
// source: schema.improbable.corelibrary.transforms.teleport.TeleportRequestStateData in improbable/corelibrary/transforms/teleport/teleport_request_state.proto.

using System;
using Improbable.Core.Serialization;
using Improbable.Entity.State;

namespace Improbable.Corelibrary.Transforms.Teleport
{
[ReaderInterface]
[CanonicalName("improbable.corelibrary.transforms.teleport.TeleportRequestState", 1901204)]
public interface TeleportRequestStateReader : IEntityStateReader
{
    Improbable.Math.Vector3d? LocalPosition { get; }
    Improbable.Corelib.Math.Quaternion? LocalRotation { get; }
    Improbable.Corelibrary.Transforms.Parent? Parent { get; }
    int Request { get; }

    event System.Action<Improbable.Math.Vector3d?> LocalPositionUpdated;
    event System.Action<Improbable.Corelib.Math.Quaternion?> LocalRotationUpdated;
    event System.Action<Improbable.Corelibrary.Transforms.Parent?> ParentUpdated;
    event System.Action<int> RequestUpdated;
}

public interface ITeleportRequestStateUpdater : IEntityStateUpdater
{
    void FinishAndSend();
    ITeleportRequestStateUpdater LocalPosition(Improbable.Math.Vector3d? newValue);
    ITeleportRequestStateUpdater LocalRotation(Improbable.Corelib.Math.Quaternion? newValue);
    ITeleportRequestStateUpdater Parent(Improbable.Corelibrary.Transforms.Parent? newValue);
    ITeleportRequestStateUpdater Request(int newValue);
}

[WriterInterface]
[CanonicalName("improbable.corelibrary.transforms.teleport.TeleportRequestState", 1901204)]
public interface TeleportRequestStateWriter : TeleportRequestStateReader, IUpdateable<ITeleportRequestStateUpdater> { }

public class TeleportRequestState : global::Improbable.Entity.State.StateBase<Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateData, Schema.Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateData>, TeleportRequestStateWriter, ITeleportRequestStateUpdater
{
    public TeleportRequestState(global::Improbable.EntityId entityId, Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateData data, IStateSender sender)
        : base(entityId, data, sender, Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateDataHelper.Instance) { }
    private static log4net.ILog LOGGER = log4net.LogManager.GetLogger(typeof(TeleportRequestState));
    private static bool ShouldLogFinishAndSendNoUpdate = true;
    private static bool ShouldLogUpdateNoFinishAndSend = true;

    protected override void LogFinishAndSendWithNoUpdate() {
        if (ShouldLogFinishAndSendNoUpdate)
        {
            ShouldLogFinishAndSendNoUpdate = false;
            LOGGER.ErrorFormat("Finish and send was called with no update in flight for entity {0}. " +
                               "This is probably due to having more StateUpdates in flight, which is an error. (Logged only once.)", EntityId);
        }
    }

    public Improbable.Math.Vector3d? LocalPosition { get { return Data.LocalPosition; } }
    public Improbable.Corelib.Math.Quaternion? LocalRotation { get { return Data.LocalRotation; } }
    public Improbable.Corelibrary.Transforms.Parent? Parent { get { return Data.Parent; } }
    public int Request { get { return Data.Request; } }

    private readonly global::System.Collections.Generic.List<System.Action<Improbable.Math.Vector3d?>> updatedCallbacksLocalPosition =
        new global::System.Collections.Generic.List<System.Action<Improbable.Math.Vector3d?>>();
    public event System.Action<Improbable.Math.Vector3d?> LocalPositionUpdated
    {
        add
        {
            updatedCallbacksLocalPosition.Add(value);
            value(Data.LocalPosition);
        }
        remove { updatedCallbacksLocalPosition.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<Improbable.Corelib.Math.Quaternion?>> updatedCallbacksLocalRotation =
        new global::System.Collections.Generic.List<System.Action<Improbable.Corelib.Math.Quaternion?>>();
    public event System.Action<Improbable.Corelib.Math.Quaternion?> LocalRotationUpdated
    {
        add
        {
            updatedCallbacksLocalRotation.Add(value);
            value(Data.LocalRotation);
        }
        remove { updatedCallbacksLocalRotation.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<Improbable.Corelibrary.Transforms.Parent?>> updatedCallbacksParent =
        new global::System.Collections.Generic.List<System.Action<Improbable.Corelibrary.Transforms.Parent?>>();
    public event System.Action<Improbable.Corelibrary.Transforms.Parent?> ParentUpdated
    {
        add
        {
            updatedCallbacksParent.Add(value);
            value(Data.Parent);
        }
        remove { updatedCallbacksParent.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<int>> updatedCallbacksRequest =
        new global::System.Collections.Generic.List<System.Action<int>>();
    public event System.Action<int> RequestUpdated
    {
        add
        {
            updatedCallbacksRequest.Add(value);
            value(Data.Request);
        }
        remove { updatedCallbacksRequest.Remove(value); }
    }

    override protected void UnsubscribeEventHandlersInternal(object visualizer)
    {
        UnsubscribeEventHandler(visualizer, updatedCallbacksLocalPosition);
        UnsubscribeEventHandler(visualizer, updatedCallbacksLocalRotation);
        UnsubscribeEventHandler(visualizer, updatedCallbacksParent);
        UnsubscribeEventHandler(visualizer, updatedCallbacksRequest);
    }

    public ITeleportRequestStateUpdater Update
    {
        get
        {
            if (Updating)
            {
                if (ShouldLogUpdateNoFinishAndSend)
                {
                    ShouldLogUpdateNoFinishAndSend = false;
                    LOGGER.ErrorFormat("Multiple state updates of entity {0} are in flight, which has undefined semantics. " +
                        "Each call to Update has to be followed by a FinishAndSend() before another call is made on the same state. (Logged only once.)", EntityId);
                }
            }
            else
            {
                Updating = true;
                Updater = new TeleportRequestStateUpdate(EntityId, new bool[3], new Schema.Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateData());
            }
            return this;
        }
    }

    ITeleportRequestStateUpdater ITeleportRequestStateUpdater.LocalPosition(Improbable.Math.Vector3d? newValue)
    {
        if ((Updater.Proto.LocalPosition != null || Updater.StatesToClear != null && Updater.StatesToClear[0]) || !global::Improbable.Util.Collections.CollectionUtil.OptionsEqual(LocalPosition, newValue))
        {
            if (newValue != null)
                Updater.Proto.LocalPosition = Improbable.Math.Vector3dHelper.Instance.ToProto(newValue.Value);
            else
                Updater.Proto.LocalPosition = null;
            Updater.StatesToClear[0] = newValue == null;
        }
        return this;
    }

    ITeleportRequestStateUpdater ITeleportRequestStateUpdater.LocalRotation(Improbable.Corelib.Math.Quaternion? newValue)
    {
        if ((Updater.Proto.LocalRotation != null || Updater.StatesToClear != null && Updater.StatesToClear[1]) || !global::Improbable.Util.Collections.CollectionUtil.OptionsEqual(LocalRotation, newValue))
        {
            if (newValue != null)
                Updater.Proto.LocalRotation = Improbable.Corelib.Math.QuaternionHelper.Instance.ToProto(newValue.Value);
            else
                Updater.Proto.LocalRotation = null;
            Updater.StatesToClear[1] = newValue == null;
        }
        return this;
    }

    ITeleportRequestStateUpdater ITeleportRequestStateUpdater.Parent(Improbable.Corelibrary.Transforms.Parent? newValue)
    {
        if ((Updater.Proto.Parent != null || Updater.StatesToClear != null && Updater.StatesToClear[2]) || !global::Improbable.Util.Collections.CollectionUtil.OptionsEqual(Parent, newValue))
        {
            if (newValue != null)
                Updater.Proto.Parent = Improbable.Corelibrary.Transforms.ParentHelper.Instance.ToProto(newValue.Value);
            else
                Updater.Proto.Parent = null;
            Updater.StatesToClear[2] = newValue == null;
        }
        return this;
    }

    ITeleportRequestStateUpdater ITeleportRequestStateUpdater.Request(int newValue)
    {
        if (Updater.Proto.RequestSpecified || !Request.Equals(newValue))
        {
            Updater.Proto.Request = newValue;
        }
        return this;
    }

    override protected bool TriggerUpdatedEvents(Schema.Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateData update, bool[] statesToClear)
    {
        bool anythingUpdated = false;
        bool updatedLocalPosition = (update.LocalPosition != null || statesToClear != null && statesToClear[0]);
        anythingUpdated |= updatedLocalPosition;
        if (updatedLocalPosition) TriggerCallbacks(updatedCallbacksLocalPosition, Data.LocalPosition);

        bool updatedLocalRotation = (update.LocalRotation != null || statesToClear != null && statesToClear[1]);
        anythingUpdated |= updatedLocalRotation;
        if (updatedLocalRotation) TriggerCallbacks(updatedCallbacksLocalRotation, Data.LocalRotation);

        bool updatedParent = (update.Parent != null || statesToClear != null && statesToClear[2]);
        anythingUpdated |= updatedParent;
        if (updatedParent) TriggerCallbacks(updatedCallbacksParent, Data.Parent);

        bool updatedRequest = update.RequestSpecified;
        anythingUpdated |= updatedRequest;
        if (updatedRequest) TriggerCallbacks(updatedCallbacksRequest, Data.Request);

        if (anythingUpdated) TriggerPropertyUpdated();
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents(Schema.Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateData stateUpdate)
    {
        bool anythingUpdated = false;
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents()
    {
        bool anythingUpdated = false;
        return anythingUpdated;
    }
}

public class TeleportRequestStateUpdate : global::Improbable.Entity.State.StateUpdate<Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateData, Schema.Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateData>
{
    public const uint COMPONENT_ID = 1901204;
    public TeleportRequestStateUpdate(global::Improbable.EntityId entityId, bool[] statesToClear, Schema.Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateData proto)
        : base(entityId, statesToClear, Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateDataHelper.Instance, proto, COMPONENT_ID) { }

    public override IReadWriteEntityState CreateState(global::Improbable.EntityId entityId, IStateSender stateSender)
    {
        return new TeleportRequestState(entityId, GetData(), stateSender);
    }

    public static TeleportRequestStateUpdate ExtractFrom(global::Improbable.Protocol.ComponentUpdate proto)
    {
        var protoState = ProtoBuf.Extensible.GetValue<Schema.Improbable.Corelibrary.Transforms.Teleport.TeleportRequestStateData>(proto.ComponentData, (int) COMPONENT_ID);
        bool[] statesToClear = new bool[3];
        for (int i = 0; i < proto.FieldsToClear.Count; i++)
        {
            statesToClear[FieldIdToIndex(proto.FieldsToClear[i])] = true;
        }
        return new TeleportRequestStateUpdate(global::Improbable.EntityIdHelper.Instance.FromProto(proto.EntityId), statesToClear, protoState);
    }

    private static uint FieldIdToIndex(uint id)
    {
        switch (id)
        {
            case 1: //localPosition
                return 0;
            case 2: //localRotation
                return 1;
            case 3: //parent
                return 2;
            default:
                throw new ArgumentException(string.Format("Unexpected error: {0} is not a valid clearable field number for state Improbable.Corelibrary.Transforms.Teleport.TeleportRequestState.", id));
        }
    }

    override protected int SeqToId(int seqId) { return seqToId[seqId]; }
    private static int[] seqToId = { 1,  2,  3, };
}
}
