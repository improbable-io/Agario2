// Generated by SpatialOS codegen. DO NOT EDIT!
// source: schema.improbable.corelibrary.transforms.global.GlobalTransformStateData in improbable/corelibrary/transforms/global/global_transform_state.proto.

using System;
using Improbable.Core.Serialization;
using Improbable.Entity.State;

namespace Improbable.Corelibrary.Transforms.Global
{
[ReaderInterface]
[CanonicalName("improbable.corelibrary.transforms.global.GlobalTransformState", 1901208)]
public interface GlobalTransformStateReader : IEntityStateReader
{
    Improbable.Math.Coordinates Position { get; }
    Improbable.Corelib.Math.Quaternion Rotation { get; }
    Improbable.Math.Vector3d Pivot { get; }
    float Timestamp { get; }

    event System.Action<Improbable.Math.Coordinates> PositionUpdated;
    event System.Action<Improbable.Corelib.Math.Quaternion> RotationUpdated;
    event System.Action<Improbable.Math.Vector3d> PivotUpdated;
    event System.Action<float> TimestampUpdated;
}

public interface IGlobalTransformStateUpdater : IEntityStateUpdater
{
    void FinishAndSend();
    IGlobalTransformStateUpdater Position(Improbable.Math.Coordinates newValue);
    IGlobalTransformStateUpdater Rotation(Improbable.Corelib.Math.Quaternion newValue);
    IGlobalTransformStateUpdater Pivot(Improbable.Math.Vector3d newValue);
    IGlobalTransformStateUpdater Timestamp(float newValue);
}

[WriterInterface]
[CanonicalName("improbable.corelibrary.transforms.global.GlobalTransformState", 1901208)]
public interface GlobalTransformStateWriter : GlobalTransformStateReader, IUpdateable<IGlobalTransformStateUpdater> { }

public class GlobalTransformState : global::Improbable.Entity.State.StateBase<Improbable.Corelibrary.Transforms.Global.GlobalTransformStateData, Schema.Improbable.Corelibrary.Transforms.Global.GlobalTransformStateData>, GlobalTransformStateWriter, IGlobalTransformStateUpdater
{
    public GlobalTransformState(global::Improbable.EntityId entityId, Improbable.Corelibrary.Transforms.Global.GlobalTransformStateData data, IStateSender sender)
        : base(entityId, data, sender, Improbable.Corelibrary.Transforms.Global.GlobalTransformStateDataHelper.Instance) { }
    private static log4net.ILog LOGGER = log4net.LogManager.GetLogger(typeof(GlobalTransformState));
    private static bool ShouldLogFinishAndSendNoUpdate = true;
    private static bool ShouldLogUpdateNoFinishAndSend = true;

    protected override void LogFinishAndSendWithNoUpdate() {
        if (ShouldLogFinishAndSendNoUpdate)
        {
            ShouldLogFinishAndSendNoUpdate = false;
            LOGGER.ErrorFormat("Finish and send was called with no update in flight for entity {0}. " +
                               "This is probably due to having more StateUpdates in flight, which is an error. (Logged only once.)", EntityId);
        }
    }

    public Improbable.Math.Coordinates Position { get { return Data.Position; } }
    public Improbable.Corelib.Math.Quaternion Rotation { get { return Data.Rotation; } }
    public Improbable.Math.Vector3d Pivot { get { return Data.Pivot; } }
    public float Timestamp { get { return Data.Timestamp; } }

    private readonly global::System.Collections.Generic.List<System.Action<Improbable.Math.Coordinates>> updatedCallbacksPosition =
        new global::System.Collections.Generic.List<System.Action<Improbable.Math.Coordinates>>();
    public event System.Action<Improbable.Math.Coordinates> PositionUpdated
    {
        add
        {
            updatedCallbacksPosition.Add(value);
            value(Data.Position);
        }
        remove { updatedCallbacksPosition.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<Improbable.Corelib.Math.Quaternion>> updatedCallbacksRotation =
        new global::System.Collections.Generic.List<System.Action<Improbable.Corelib.Math.Quaternion>>();
    public event System.Action<Improbable.Corelib.Math.Quaternion> RotationUpdated
    {
        add
        {
            updatedCallbacksRotation.Add(value);
            value(Data.Rotation);
        }
        remove { updatedCallbacksRotation.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<Improbable.Math.Vector3d>> updatedCallbacksPivot =
        new global::System.Collections.Generic.List<System.Action<Improbable.Math.Vector3d>>();
    public event System.Action<Improbable.Math.Vector3d> PivotUpdated
    {
        add
        {
            updatedCallbacksPivot.Add(value);
            value(Data.Pivot);
        }
        remove { updatedCallbacksPivot.Remove(value); }
    }

    private readonly global::System.Collections.Generic.List<System.Action<float>> updatedCallbacksTimestamp =
        new global::System.Collections.Generic.List<System.Action<float>>();
    public event System.Action<float> TimestampUpdated
    {
        add
        {
            updatedCallbacksTimestamp.Add(value);
            value(Data.Timestamp);
        }
        remove { updatedCallbacksTimestamp.Remove(value); }
    }

    override protected void UnsubscribeEventHandlersInternal(object visualizer)
    {
        UnsubscribeEventHandler(visualizer, updatedCallbacksPosition);
        UnsubscribeEventHandler(visualizer, updatedCallbacksRotation);
        UnsubscribeEventHandler(visualizer, updatedCallbacksPivot);
        UnsubscribeEventHandler(visualizer, updatedCallbacksTimestamp);
    }

    public IGlobalTransformStateUpdater Update
    {
        get
        {
            if (Updating)
            {
                if (ShouldLogUpdateNoFinishAndSend)
                {
                    ShouldLogUpdateNoFinishAndSend = false;
                    LOGGER.ErrorFormat("Multiple state updates of entity {0} are in flight, which has undefined semantics. " +
                        "Each call to Update has to be followed by a FinishAndSend() before another call is made on the same state. (Logged only once.)", EntityId);
                }
            }
            else
            {
                Updating = true;
                Updater = new GlobalTransformStateUpdate(EntityId, new bool[0], new Schema.Improbable.Corelibrary.Transforms.Global.GlobalTransformStateData());
            }
            return this;
        }
    }

    IGlobalTransformStateUpdater IGlobalTransformStateUpdater.Position(Improbable.Math.Coordinates newValue)
    {
        if (Updater.Proto.Position != null || !Position.Equals(newValue))
        {
            Updater.Proto.Position = Improbable.Math.CoordinatesHelper.Instance.ToProto(newValue);
        }
        return this;
    }

    IGlobalTransformStateUpdater IGlobalTransformStateUpdater.Rotation(Improbable.Corelib.Math.Quaternion newValue)
    {
        if (Updater.Proto.Rotation != null || !Rotation.Equals(newValue))
        {
            Updater.Proto.Rotation = Improbable.Corelib.Math.QuaternionHelper.Instance.ToProto(newValue);
        }
        return this;
    }

    IGlobalTransformStateUpdater IGlobalTransformStateUpdater.Pivot(Improbable.Math.Vector3d newValue)
    {
        if (Updater.Proto.Pivot != null || !Pivot.Equals(newValue))
        {
            Updater.Proto.Pivot = Improbable.Math.Vector3dHelper.Instance.ToProto(newValue);
        }
        return this;
    }

    IGlobalTransformStateUpdater IGlobalTransformStateUpdater.Timestamp(float newValue)
    {
        if (Updater.Proto.TimestampSpecified || !Timestamp.Equals(newValue))
        {
            Updater.Proto.Timestamp = newValue;
        }
        return this;
    }

    override protected bool TriggerUpdatedEvents(Schema.Improbable.Corelibrary.Transforms.Global.GlobalTransformStateData update, bool[] statesToClear)
    {
        bool anythingUpdated = false;
        bool updatedPosition = update.Position != null;
        anythingUpdated |= updatedPosition;
        if (updatedPosition) TriggerCallbacks(updatedCallbacksPosition, Data.Position);

        bool updatedRotation = update.Rotation != null;
        anythingUpdated |= updatedRotation;
        if (updatedRotation) TriggerCallbacks(updatedCallbacksRotation, Data.Rotation);

        bool updatedPivot = update.Pivot != null;
        anythingUpdated |= updatedPivot;
        if (updatedPivot) TriggerCallbacks(updatedCallbacksPivot, Data.Pivot);

        bool updatedTimestamp = update.TimestampSpecified;
        anythingUpdated |= updatedTimestamp;
        if (updatedTimestamp) TriggerCallbacks(updatedCallbacksTimestamp, Data.Timestamp);

        if (anythingUpdated) TriggerPropertyUpdated();
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents(Schema.Improbable.Corelibrary.Transforms.Global.GlobalTransformStateData stateUpdate)
    {
        bool anythingUpdated = false;
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents()
    {
        bool anythingUpdated = false;
        return anythingUpdated;
    }
}

public class GlobalTransformStateUpdate : global::Improbable.Entity.State.StateUpdate<Improbable.Corelibrary.Transforms.Global.GlobalTransformStateData, Schema.Improbable.Corelibrary.Transforms.Global.GlobalTransformStateData>
{
    public const uint COMPONENT_ID = 1901208;
    public GlobalTransformStateUpdate(global::Improbable.EntityId entityId, bool[] statesToClear, Schema.Improbable.Corelibrary.Transforms.Global.GlobalTransformStateData proto)
        : base(entityId, statesToClear, Improbable.Corelibrary.Transforms.Global.GlobalTransformStateDataHelper.Instance, proto, COMPONENT_ID) { }

    public override IReadWriteEntityState CreateState(global::Improbable.EntityId entityId, IStateSender stateSender)
    {
        return new GlobalTransformState(entityId, GetData(), stateSender);
    }

    public static GlobalTransformStateUpdate ExtractFrom(global::Improbable.Protocol.ComponentUpdate proto)
    {
        var protoState = ProtoBuf.Extensible.GetValue<Schema.Improbable.Corelibrary.Transforms.Global.GlobalTransformStateData>(proto.ComponentData, (int) COMPONENT_ID);
        return new GlobalTransformStateUpdate(global::Improbable.EntityIdHelper.Instance.FromProto(proto.EntityId), null, protoState);
    }

    override protected int SeqToId(int seqId) { return seqToId[seqId]; }
    private static int[] seqToId = {};
}
}
