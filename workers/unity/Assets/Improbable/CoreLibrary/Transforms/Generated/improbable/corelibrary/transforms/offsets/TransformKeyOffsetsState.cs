// Generated by SpatialOS codegen. DO NOT EDIT!
// source: schema.improbable.corelibrary.transforms.offsets.TransformKeyOffsetsStateData in improbable/corelibrary/transforms/offsets/transform_key_offsets_state.proto.

using System;
using Improbable.Core.Serialization;
using Improbable.Entity.State;

namespace Improbable.Corelibrary.Transforms.Offsets
{
[ReaderInterface]
[CanonicalName("improbable.corelibrary.transforms.offsets.TransformKeyOffsetsState", 1901206)]
public interface TransformKeyOffsetsStateReader : IEntityStateReader
{
    global::Improbable.Util.Collections.IReadOnlyDictionary<string, Improbable.Corelibrary.Transforms.Transform> KeyMap { get; }

    event System.Action<global::Improbable.Util.Collections.IReadOnlyDictionary<string, Improbable.Corelibrary.Transforms.Transform>> KeyMapUpdated;
}

public interface ITransformKeyOffsetsStateUpdater : IEntityStateUpdater
{
    void FinishAndSend();
    ITransformKeyOffsetsStateUpdater KeyMap(global::System.Collections.Generic.IDictionary<string, Improbable.Corelibrary.Transforms.Transform> newValue);
}

[WriterInterface]
[CanonicalName("improbable.corelibrary.transforms.offsets.TransformKeyOffsetsState", 1901206)]
public interface TransformKeyOffsetsStateWriter : TransformKeyOffsetsStateReader, IUpdateable<ITransformKeyOffsetsStateUpdater> { }

public class TransformKeyOffsetsState : global::Improbable.Entity.State.StateBase<Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateData, Schema.Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateData>, TransformKeyOffsetsStateWriter, ITransformKeyOffsetsStateUpdater
{
    public TransformKeyOffsetsState(global::Improbable.EntityId entityId, Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateData data, IStateSender sender)
        : base(entityId, data, sender, Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateDataHelper.Instance) { }
    private static log4net.ILog LOGGER = log4net.LogManager.GetLogger(typeof(TransformKeyOffsetsState));
    private static bool ShouldLogFinishAndSendNoUpdate = true;
    private static bool ShouldLogUpdateNoFinishAndSend = true;

    protected override void LogFinishAndSendWithNoUpdate() {
        if (ShouldLogFinishAndSendNoUpdate)
        {
            ShouldLogFinishAndSendNoUpdate = false;
            LOGGER.ErrorFormat("Finish and send was called with no update in flight for entity {0}. " +
                               "This is probably due to having more StateUpdates in flight, which is an error. (Logged only once.)", EntityId);
        }
    }

    public global::Improbable.Util.Collections.IReadOnlyDictionary<string, Improbable.Corelibrary.Transforms.Transform> KeyMap { get { return Data.KeyMap; } }

    private readonly global::System.Collections.Generic.List<System.Action<global::Improbable.Util.Collections.IReadOnlyDictionary<string, Improbable.Corelibrary.Transforms.Transform>>> updatedCallbacksKeyMap =
        new global::System.Collections.Generic.List<System.Action<global::Improbable.Util.Collections.IReadOnlyDictionary<string, Improbable.Corelibrary.Transforms.Transform>>>();
    public event System.Action<global::Improbable.Util.Collections.IReadOnlyDictionary<string, Improbable.Corelibrary.Transforms.Transform>> KeyMapUpdated
    {
        add
        {
            updatedCallbacksKeyMap.Add(value);
            value(Data.KeyMap);
        }
        remove { updatedCallbacksKeyMap.Remove(value); }
    }

    override protected void UnsubscribeEventHandlersInternal(object visualizer)
    {
        UnsubscribeEventHandler(visualizer, updatedCallbacksKeyMap);
    }

    public ITransformKeyOffsetsStateUpdater Update
    {
        get
        {
            if (Updating)
            {
                if (ShouldLogUpdateNoFinishAndSend)
                {
                    ShouldLogUpdateNoFinishAndSend = false;
                    LOGGER.ErrorFormat("Multiple state updates of entity {0} are in flight, which has undefined semantics. " +
                        "Each call to Update has to be followed by a FinishAndSend() before another call is made on the same state. (Logged only once.)", EntityId);
                }
            }
            else
            {
                Updating = true;
                Updater = new TransformKeyOffsetsStateUpdate(EntityId, new bool[1], new Schema.Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateData());
            }
            return this;
        }
    }

    ITransformKeyOffsetsStateUpdater ITransformKeyOffsetsStateUpdater.KeyMap(global::System.Collections.Generic.IDictionary<string, Improbable.Corelibrary.Transforms.Transform> newValue)
    {
        if ((Updater.Proto.KeyMap.Count > 0 || Updater.StatesToClear != null && Updater.StatesToClear[0]) || !global::Improbable.Util.Collections.CollectionUtil.DictionariesEqual(KeyMap, newValue))
        {
            global::Improbable.Tools.ToProto(newValue, Updater.Proto.KeyMap, Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateDataHelper.KeyMapEntryHelper.Instance);
            Updater.StatesToClear[0] = newValue.Count == 0;
        }
        return this;
    }

    override protected bool TriggerUpdatedEvents(Schema.Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateData update, bool[] statesToClear)
    {
        bool anythingUpdated = false;
        bool updatedKeyMap = (update.KeyMap.Count > 0 || statesToClear != null && statesToClear[0]);
        anythingUpdated |= updatedKeyMap;
        if (updatedKeyMap) TriggerCallbacks(updatedCallbacksKeyMap, Data.KeyMap);

        if (anythingUpdated) TriggerPropertyUpdated();
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents(Schema.Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateData stateUpdate)
    {
        bool anythingUpdated = false;
        return anythingUpdated;
    }

    override protected bool TriggerAllStateEvents()
    {
        bool anythingUpdated = false;
        return anythingUpdated;
    }
}

public class TransformKeyOffsetsStateUpdate : global::Improbable.Entity.State.StateUpdate<Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateData, Schema.Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateData>
{
    public const uint COMPONENT_ID = 1901206;
    public TransformKeyOffsetsStateUpdate(global::Improbable.EntityId entityId, bool[] statesToClear, Schema.Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateData proto)
        : base(entityId, statesToClear, Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateDataHelper.Instance, proto, COMPONENT_ID) { }

    public override IReadWriteEntityState CreateState(global::Improbable.EntityId entityId, IStateSender stateSender)
    {
        return new TransformKeyOffsetsState(entityId, GetData(), stateSender);
    }

    public static TransformKeyOffsetsStateUpdate ExtractFrom(global::Improbable.Protocol.ComponentUpdate proto)
    {
        var protoState = ProtoBuf.Extensible.GetValue<Schema.Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsStateData>(proto.ComponentData, (int) COMPONENT_ID);
        bool[] statesToClear = new bool[1];
        for (int i = 0; i < proto.FieldsToClear.Count; i++)
        {
            statesToClear[FieldIdToIndex(proto.FieldsToClear[i])] = true;
        }
        return new TransformKeyOffsetsStateUpdate(global::Improbable.EntityIdHelper.Instance.FromProto(proto.EntityId), statesToClear, protoState);
    }

    private static uint FieldIdToIndex(uint id)
    {
        switch (id)
        {
            case 1: //keyMap
                return 0;
            default:
                throw new ArgumentException(string.Format("Unexpected error: {0} is not a valid clearable field number for state Improbable.Corelibrary.Transforms.Offsets.TransformKeyOffsetsState.", id));
        }
    }

    override protected int SeqToId(int seqId) { return seqToId[seqId]; }
    private static int[] seqToId = { 1, };
}
}
